var documenterSearchIndex = {"docs":
[{"location":"formats/eeg/#EEG","page":"EEG (BrainVision)","title":"EEG","text":"","category":"section"},{"location":"reference/#BioSemi-BDF","page":"Reference","title":"BioSemi BDF","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"load_bdf.jl\"]","category":"page"},{"location":"reference/#EEGIO.read_bdf-Tuple{String}","page":"Reference","title":"EEGIO.read_bdf","text":"read_bdf(f::String; kwargs...)\n\nRead data from a BDF file.\n\nProviding a string containing valid path to a .bdf file will result in reading the data as a Float64 matrix with an added offset. Behavior of the function can be altered through additional keyword arguments listed below. Please consult the online documentation for a more thorough explanation of different options.\n\nArguments:\n\nf::String\nPath to the BDF file to be read.\n\nKeywords:\n\nonlyHeader::Bool=false\nIndicates whether to read the header information with data points or just the header.\naddOffset::Bool=true\nWhether to add constant offset to data points to compensate for asymmetric digitalization done by the amplifier. This setting differs between software. Defaults to true.\nnumPrecision::Type=Float64\nSpecifies the numerical type of the data. Data points in BDF files are stored as signed 24-bit integers, therefore can be read as types with higher bit count per number. Possible tested options: Float32, Float64, Int32, Int64. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  Float64.\nchanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All\nSpecifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.\nchanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None\nSpecifies the subset of channel to omit while reading the data. Uses the same selectors as chanSelect and picked values are subtracted from the set of electrodes chosen by chanSelect. Default is set to :None.\ntimeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All\nSpecifies the part of the time course of the data to be read. BDF files are read one record at a time (just as they are written), so the user can indicate which records to read. Using integers will select records with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all records that fit this time span will be read. Using Symbol :All will read every record in the file. This is also the default.\nreadStatus::Bool=true\nSpecifies if the Status channel should be read. As this is a special channel, always placed at the end of the file and carrying trigger information along with some technical data about the hardware setup, this setting provides an option to ignore it. Please be aware, that its absence might generate errors in code that expects it (even if it is empty). Default is set to true. \n\nCurrent implementation follows closely the specification formulated by BioSemi that extends EDF format from 16 to 24-bit. Therefore it will read only data produced by BioSemi equipment and software compliant with the specification. BDF+ extension is not yet implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.read_bdf_header-Tuple{IO}","page":"Reference","title":"EEGIO.read_bdf_header","text":"read_bdf_header(::IO)\n\nRead the header of a BDF file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BrainVision-EEG","page":"Reference","title":"BrainVision EEG","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"load_eeg.jl\"]","category":"page"},{"location":"reference/#EEGIO.read_eeg-Tuple{String}","page":"Reference","title":"EEGIO.read_eeg","text":"read_eeg(f::String; kwargs...)\n\nRead data from an EEG file.\n\nProviding a string containing valid path to a .eeg, .vhdr, or .vmrk file will result in  reading the data as a Float64 matrix (provided all files share their name). Behavior of  the function can be altered through additional keyword arguments listed below. Please  consult the online documentation for a more thorough explanation of different options.\n\nArguments:\n\nf::String\nPath to the EEG file (either .eeg, .vhdr, or .vmrk) to be read.\n\nKeywords:\n\nonlyHeader::Bool=false\nIndicates whether to read the header information with data points or just the header.\nonlyMarkers::Bool=false\nIndicates whether to read the data points or just the header and markers.\nnumPrecision::Type=Float64\nSpecifies the numerical type of the data. Data points in EEG files are stored as 16-bit integers or 32-bit floats, therefore can be read as types with higher bit count per number. Possible tested options: Float32, Float64, Int32, Int64. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  Float64.\nchanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All\nSpecifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.\nchanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None\nSpecifies the subset of channel to omit while reading the data. Uses the same selectors as chanSelect and picked values are subtracted from the set of electrodes chosen by chanSelect. Default is set to :None.\ntimeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All\nSpecifies the part of the time course of the data to be read. Using integers will select samples with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all samples that fit this time span will be read. Using Symbol :All will read every sample in the file. This is also the default.\n\nCurrent implementation follows closely the specification formulated by BrainVision. However the contents of the header and marker files can differ substantially,  even if recorded with BrainVision hardware. If your files are not read properly, open an issue on github and try to provide a sample dataset to reproduce the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.read_eeg_header-Tuple{String}","page":"Reference","title":"EEGIO.read_eeg_header","text":"read_eeg_header(::String)\n\nReader the EEG header based on the name of file. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"pick_channels.jl\", \"pick_samples.jl\", \"resize.jl\"]","category":"page"},{"location":"reference/#EEGIO.pick_channels-Tuple{Any, Integer, Vector{String}}","page":"Reference","title":"EEGIO.pick_channels","text":"EEGIO.pick_channels(channels, nChannels::Integer, chanLabels::Vector{String})\n\nInternal function used to properly select requested subset of channels from the data. It allows users to narrow down the number of read channels through numerical indexes, or name labels picked directly with a list or matched with regex expression.\n\nAlways returns a vector of indices corresponding to the picked channels.\n\nExamples\n\n# Assume we have an object `raw` of type BDF with 10 channels.\n\n# Picking the first channel of the data.\npick_channels(1, raw.header.nChannels, raw.header.chanLabels)\n\n# Picking the first 5 channels of the data.\npick_channels(1:5, raw.header.nChannels, raw.header.chanLabels)\n\n# Picking channels Fp1, Fp2, F7, F3, and Fz.\npick_channels([\"Fp1\", \"Fp2\", \"F7\", \"F3\", \"Fz\"], raw.header.nChannels, raw.header.chanLabels)\n\n# Picking all channels that contain the letter \"F\".\npick_channels(r\"F\", raw.header.nChannels, raw.header.chanLabels)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.pick_samples-Tuple{Any, Any}","page":"Reference","title":"EEGIO.pick_samples","text":"EEGIO.pick_samples(records, header::BDFHeader)\nEEGIO.pick_samples(samples, nDataSamples::Ineger, header::EEGHeader)\n\nInternal function used to properly pick the range of samples that should be read from every channel. Since data is stored differently in each format, specialized variants were written to read as much data as needed to satify the query without compromising efficiency. Please refer to the description of timeSelect keyword argument of particular read function for more detailed account of the picking behaviour.\n\nAlways returns a UnitRange.\n\nExamples\n\n# Picking the first 10 records of the data (assuming `file` is an object of type BDF).\npick_samples(1:10, file.header)\n\n# Picking the first 10 seconds of the data (assuming `file` is an object of type EEG).\npick_samples((1.,10.), size(file.data,1), file.header)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.split-Tuple{EEGData}","page":"Reference","title":"Base.split","text":"split(file::EEGData, timepoint)\n\nAllows for splitting the data into two objects at a specified timepoint. timepoint can be either a Float or an Integer. Depending on the format, the timepoint will be measured in different units. To preserve the structure of the underlying format, e.g. BDF files will be split based on the record duration. Returns two new EEGData objects with the split data.\n\nExamples\n\n# Splitting the data at the 10th second of the file.\ndata1, data2 = split(file, 10.)\n\n# Splitting the data at the 100th sample/record of the file.\ndata1, data2 = split(file, 100)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.crop!-Tuple{BDF, Any}","page":"Reference","title":"EEGIO.crop!","text":"crop!(file::EEGData, timeSelect)\n\nPerforms cropping in place. See crop for more details. \n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.crop-Tuple{EEGData}","page":"Reference","title":"EEGIO.crop","text":"crop(file::EEGData, timeSelect)\n\nAllows for cropping the data to a specified time window. timeSelect can be either an Integer,  a UnitRange, or a tuple of Floats. Depending on the format, the time window will be measured in different units. Since this keyword argument works exactly the same as in read functions, please refer to their documentation for more details on specific use cases. Returns a new EEGData object with the cropped data.\n\nExamples\n\n# Cropping the data to the first 10 seconds of the file.\ndata = crop(file, (1.,10.))\n\n# Cropping the data to the first 10 samples/records of the file.\ndata = crop(file, 1:10)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.select!-Tuple{BDF, Any}","page":"Reference","title":"EEGIO.select!","text":"select!(file::EEGData, chanSelect)\n\nPerforms channel selection in place. See select for more details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.select-Tuple{EEGData}","page":"Reference","title":"EEGIO.select","text":"select(file::EEGData, chanSelect)\n\nAllows for selecting a subset of channels from the original data. chanSelect can be either an Integer, a UnitRange, a Vector of Integers/Strings, or a regular expression. Behaves exactly the same as in read functions. Returns a new EEGData object with only the selected channels.\n\nExamples\n\n# Selecting the first 10 channels from the file.\ndata = select(file, 1:10)\n\n# Selecting channels 1, 3, 5, and 7 from the file.\ndata = select(file, [1,3,5,7])\n\n# Selecting only frontal channels (labels containing the letter \"F\") from the file.\ndata = select(file, r\"F\")\n\n\n\n\n\n","category":"method"},{"location":"#EEGIO-Package","page":"Home","title":"EEGIO Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The EEGIO package allows for loading and saving EEG data from most popular formats. It is configured to extend the FileIO interface for better discoverability and ease-of-use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main focus of the package is to provide access to all of the data stored in files. Therefore each format has its own type that is meant to provide easy way to see and extract data for further use. For implementation details, please see the dedicated pages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Right now, EEGIO supports following formats:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BDF (load and save)\nEEG (load and save)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are interested in processing and analyzing EEG data in Julia, and would like a more general interface for working with data, check out Telepathy for which EEGIO serves as an IO backend. It should have reasonable default settings for start, while still allowing you to do all of the customisations included in EEGIO.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the 1.0 release, we would like to support loading and saving of all the formats included in EEG-BIDS specification. This includes support for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDF files\nEDF+ and BDF+ extensions\nEEGLab files (.set and .fdt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to see other formats (or even better, help to implement them), please open an issue for it.\n\n\n","category":"page"},{"location":"#Other-packages","page":"Home","title":"Other packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, Julia ecosystem lacks a package serving as a singular entry point for EEG data (a role which EEGIO aspires to fill). There are however packages that implement reading and writing functions for some formats.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BDF/EDF: EDF.jl, EDFplus.jl, BDF.jl, BioSemiBDF\nBrainVision: brainvisionloader.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, there are more general packages that include IO functionality:\nNeuroimaging.jl and NeuroAnalyzer.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, there are many well established libraries in other languages that support reading and writing these files (along with tools for analysis). Most popular ones include EEGLab, FieldTrip, and Brainstorm for Matlab; MNE-Python for Python. You should be able to easily find more browsing Github or Google results.","category":"page"},{"location":"formats/bdf/#BDF","page":"BDF (BioSemi)","title":"BDF","text":"","category":"section"}]
}
