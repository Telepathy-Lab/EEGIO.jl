var documenterSearchIndex = {"docs":
[{"location":"formats/eeg/#EEG","page":"EEG (BrainVision)","title":"EEG","text":"","category":"section"},{"location":"reference/#BioSemi-BDF","page":"Reference","title":"BioSemi BDF","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"BDF.jl\", \"load_bdf.jl\"]","category":"page"},{"location":"reference/#EEGIO.BDF-Tuple{Array, Integer}","page":"Reference","title":"EEGIO.BDF","text":"BDF(data::Array, sRate::Integer; path=\"\", file=\"\", kwargs...)\n\nCovenience constructor for BDF struct. To get a valid BDF struct, you need to provide the data and its sampling rate. All other keyword arguments are optional and will be passed to the BDFHeader constructor. Although optional, the more information you provide, the less likely you will face problems when importing the data into other software.\n\nArguments\n\ndata::Array: 2D matrix of data. Each row represents a sample and each column a channel.\nsRate::Integer: Sampling rate of the data in Hz.\n\nKeyword arguments\n\npath::String: Path to the folder where the file will be saved. If not provided, you will\n\nhave to provide the full path when calling the write_bdf function.\n\nfile::String: Name of the file. If not provided, you will have to provide in the path.\nsubID::String: Subject ID.\nrecID::String: Recording ID.\nstartDate::String: Date of the recording.\nstartTime::String: Time of the recording.\nrecordDuration::Integer: Duration of each data record in seconds.\nchanLabels::Vector{String}: Channel labels.\ntransducer::Vector{String}: Transducer type, eg. 'active electrode'.\nphysDim::Vector{String}: Physical dimension of the data, eg. 'uV'.\nphysMin::Vector{Int}: Minimum physical value of the data.\nphysMax::Vector{Int}: Maximum physical value of the data.\ndigMin::Vector{Int}: Minimum digital value of the data.\ndigMax::Vector{Int}: Maximum digital value of the data.\nprefilt::Vector{String}: Prefiltering of the data, eg. 'HP:0.1Hz LP:75Hz'.\nreserved::Vector{String}: Reserved fields (usually empty).\n\nReturns\n\nBDF: BDF struct.\n\nAdditionally, this constructor provides validation checks that might help you avoid mistakes or getting the data distorted during conversion to Int24 while writing to disk.\n\nExamples\n\n# Create a BDF struct with 10s of random data and 20 channels sampled at 256Hz.\nBDF(rand(2560, 20), 256)\n\nIf you already have a BDFHeader, you can use the default constructor:\n\nBDF(header, data, path=\"path/to/file/\", file=\"file.bdf\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.BDFHeader-Tuple{Integer, Integer, Integer}","page":"Reference","title":"EEGIO.BDFHeader","text":"BDFHeader(samples::Integer, channels::Integer, sRate::Integer; kwargs...)\n\nConvenience constructor for the BDFHeader struct. The only three necessary arguments is the number of samples in the data, the number of channels, and the sampling rate of signals. Other fields are optional, but providing them might improve compatibility with other software.\n\nArguments\n\nsamples::Integer: Number of samples in the data.\nchannels::Integer: Number of channels in the data.\nsRate::Integer: Sampling rate of the data.\n\nKeyword arguments\n\nsubID::String: Subject ID.\nrecID::String: Recording ID.\nstartDate::String: Date of the recording.\nstartTime::String: Time of the recording.\nrecordDuration::Integer: Duration of each data record in seconds.\nchanLabels::Vector{String}: Channel labels.\ntransducer::Vector{String}: Transducer type, eg. 'active electrode'.\nphysDim::Vector{String}: Physical dimension of the data, eg. 'uV'.\nphysMin::Vector{Int}: Minimum physical value of the data.\nphysMax::Vector{Int}: Maximum physical value of the data.\ndigMin::Vector{Int}: Minimum digital value of the data.\ndigMax::Vector{Int}: Maximum digital value of the data.\nprefilt::Vector{String}: Prefiltering of the data, eg. 'HP:0.1Hz LP:75Hz'.\nreserved::Vector{String}: Reserved fields (usually empty).\n\nReturns\n\nBDFHeader: A BDFHeader struct with the provided values.\n\nYou might notice that couple of fields mentioned in the BDF specification are not included  in the constructor. These either have a fixed value or are calculated from provided values to reduce the risk of mistakes. If you want to change these values, you can overwrite the fields of the returned struct directly or use the default constructor and fill all the fields manually. However, this constructor provides additional validation checks that might help you avoid entering wrong values or getting the data distorted during conversion to Int24 while writing  to disk.\n\nExamples\n\nheader = BDFHeader(1024, 17, 256)\n\nheader = BDFHeader(1024, 17, 256, subID=\"Subject 1\", recID=\"Recording 1\", startDate=\"01.01.2019\", startTime=\"00:00:00\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.read_bdf-Tuple{String}","page":"Reference","title":"EEGIO.read_bdf","text":"read_bdf(f::String; kwargs...)\n\nRead data from a BDF file.\n\nProviding a string containing valid path to a .bdf file will result in reading the data as a Float64 matrix with an added offset. Behavior of the function can be altered through additional keyword arguments listed below. Please consult the online documentation for a more thorough explanation of different options.\n\nArguments:\n\nf::String\nPath to the BDF file to be read.\n\nKeywords:\n\nonlyHeader::Bool=false\nIndicates whether to read the header information with data points or just the header.\naddOffset::Bool=true\nWhether to add constant offset to data points to compensate for asymmetric digitalization done by the amplifier. This setting differs between software. Defaults to true.\nnumPrecision::Type=Float64\nSpecifies the numerical type of the data. Data points in BDF files are stored as signed 24-bit integers, therefore can be read as types with higher bit count per number. Possible tested options: Float32, Float64, Int32, Int64. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  Float64.\nchanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All\nSpecifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.\nchanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None\nSpecifies the subset of channel to omit while reading the data. Uses the same selectors as chanSelect and picked values are subtracted from the set of electrodes chosen by chanSelect. Default is set to :None.\ntimeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All\nSpecifies the part of the time course of the data to be read. BDF files are read one record at a time (just as they are written), so the user can indicate which records to read. Using integers will select records with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all records that fit this time span will be read. Using Symbol :All will read every record in the file. This is also the default.\nreadStatus::Bool=true\nSpecifies if the Status channel should be read. As this is a special channel, always placed at the end of the file and carrying trigger information along with some technical data about the hardware setup, this setting provides an option to ignore it. Please be aware, that its absence might generate errors in code that expects it (even if it is empty). Default is set to true. \n\nCurrent implementation follows closely the specification formulated by BioSemi that extends EDF format from 16 to 24-bit. Therefore it will read only data produced by BioSemi equipment and software compliant with the specification. BDF+ extension is not yet implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.read_bdf_header-Tuple{IO}","page":"Reference","title":"EEGIO.read_bdf_header","text":"read_bdf_header(::IO)\n\nRead the header of a BDF file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BrainVision-EEG","page":"Reference","title":"BrainVision EEG","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"load_eeg.jl\"]","category":"page"},{"location":"reference/#EEGIO.read_eeg-Tuple{String}","page":"Reference","title":"EEGIO.read_eeg","text":"read_eeg(f::String; kwargs...)\n\nRead data from an EEG file.\n\nProviding a string containing valid path to a .eeg, .vhdr, or .vmrk file will result in  reading the data as a Float64 matrix (provided all files share their name). Behavior of  the function can be altered through additional keyword arguments listed below. Please  consult the online documentation for a more thorough explanation of different options.\n\nArguments:\n\nf::String\nPath to the EEG file (either .eeg, .vhdr, or .vmrk) to be read.\n\nKeywords:\n\nonlyHeader::Bool=false\nIndicates whether to read the header information with data points or just the header.\nonlyMarkers::Bool=false\nIndicates whether to read the data points or just the header and markers.\nnumPrecision::Type=Float64\nSpecifies the numerical type of the data. Data points in EEG files are stored as 16-bit integers or 32-bit floats, therefore can be read as types with higher bit count per number. Possible tested options: Float32, Float64, Int32, Int64. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  Float64.\nchanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All\nSpecifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.\nchanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None\nSpecifies the subset of channel to omit while reading the data. Uses the same selectors as chanSelect and picked values are subtracted from the set of electrodes chosen by chanSelect. Default is set to :None.\ntimeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All\nSpecifies the part of the time course of the data to be read. Using integers will select samples with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all samples that fit this time span will be read. Using Symbol :All will read every sample in the file. This is also the default.\n\nCurrent implementation follows closely the specification formulated by BrainVision. However the contents of the header and marker files can differ substantially,  even if recorded with BrainVision hardware. If your files are not read properly, open an issue on github and try to provide a sample dataset to reproduce the problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.read_eeg_header-Tuple{String}","page":"Reference","title":"EEGIO.read_eeg_header","text":"read_eeg_header(::String)\n\nReader the EEG header based on the name of file. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [EEGIO]\nPages = [\"pick_channels.jl\", \"pick_samples.jl\", \"resize.jl\"]","category":"page"},{"location":"reference/#EEGIO.pick_channels-Tuple{Any, Integer, Vector{String}}","page":"Reference","title":"EEGIO.pick_channels","text":"EEGIO.pick_channels(channels, nChannels::Integer, chanLabels::Vector{String})\n\nInternal function used to properly select requested subset of channels from the data. It allows users to narrow down the number of read channels through numerical indexes, or name labels picked directly with a list or matched with regex expression.\n\nAlways returns a vector of indices corresponding to the picked channels.\n\nExamples\n\n# Assume we have an object `raw` of type BDF with 10 channels.\n\n# Picking the first channel of the data.\npick_channels(1, raw.header.nChannels, raw.header.chanLabels)\n\n# Picking the first 5 channels of the data.\npick_channels(1:5, raw.header.nChannels, raw.header.chanLabels)\n\n# Picking channels Fp1, Fp2, F7, F3, and Fz.\npick_channels([\"Fp1\", \"Fp2\", \"F7\", \"F3\", \"Fz\"], raw.header.nChannels, raw.header.chanLabels)\n\n# Picking all channels that contain the letter \"F\".\npick_channels(r\"F\", raw.header.nChannels, raw.header.chanLabels)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.pick_samples-Tuple{Any, Any}","page":"Reference","title":"EEGIO.pick_samples","text":"EEGIO.pick_samples(records, header::BDFHeader)\nEEGIO.pick_samples(samples, nDataSamples::Ineger, header::EEGHeader)\n\nInternal function used to properly pick the range of samples that should be read from every channel. Since data is stored differently in each format, specialized variants were written to read as much data as needed to satify the query without compromising efficiency. Please refer to the description of timeSelect keyword argument of particular read function for more detailed account of the picking behaviour.\n\nAlways returns a UnitRange.\n\nExamples\n\n# Picking the first 10 records of the data (assuming `file` is an object of type BDF).\npick_samples(1:10, file.header)\n\n# Picking the first 10 seconds of the data (assuming `file` is an object of type EEG).\npick_samples((1.,10.), size(file.data,1), file.header)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.split-Tuple{EEGData}","page":"Reference","title":"Base.split","text":"split(file::EEGData, timepoint)\n\nAllows for splitting the data into two objects at a specified timepoint. timepoint can be either a Float or an Integer. Depending on the format, the timepoint will be measured in different units. To preserve the structure of the underlying format, e.g. BDF files will be split based on the record duration. Returns two new EEGData objects with the split data.\n\nExamples\n\n# Splitting the data at the 10th second of the file.\ndata1, data2 = split(file, 10.)\n\n# Splitting the data at the 100th sample/record of the file.\ndata1, data2 = split(file, 100)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.crop!-Tuple{BDF, Any}","page":"Reference","title":"EEGIO.crop!","text":"crop!(file::EEGData, timeSelect)\n\nPerforms cropping in place. See crop for more details. \n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.crop-Tuple{EEGData}","page":"Reference","title":"EEGIO.crop","text":"crop(file::EEGData, timeSelect)\n\nAllows for cropping the data to a specified time window. timeSelect can be either an Integer,  a UnitRange, or a tuple of Floats. Depending on the format, the time window will be measured in different units. Since this keyword argument works exactly the same as in read functions, please refer to their documentation for more details on specific use cases. Returns a new EEGData object with the cropped data.\n\nExamples\n\n# Cropping the data to the first 10 seconds of the file.\ndata = crop(file, (1.,10.))\n\n# Cropping the data to the first 10 samples/records of the file.\ndata = crop(file, 1:10)\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.select!-Tuple{BDF, Any}","page":"Reference","title":"EEGIO.select!","text":"select!(file::EEGData, chanSelect)\n\nPerforms channel selection in place. See select for more details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#EEGIO.select-Tuple{EEGData}","page":"Reference","title":"EEGIO.select","text":"select(file::EEGData, chanSelect)\n\nAllows for selecting a subset of channels from the original data. chanSelect can be either an Integer, a UnitRange, a Vector of Integers/Strings, or a regular expression. Behaves exactly the same as in read functions. Returns a new EEGData object with only the selected channels.\n\nExamples\n\n# Selecting the first 10 channels from the file.\ndata = select(file, 1:10)\n\n# Selecting channels 1, 3, 5, and 7 from the file.\ndata = select(file, [1,3,5,7])\n\n# Selecting only frontal channels (labels containing the letter \"F\") from the file.\ndata = select(file, r\"F\")\n\n\n\n\n\n","category":"method"},{"location":"#EEGIO-Package","page":"Home","title":"EEGIO Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The EEGIO package allows for loading and saving EEG data from most popular formats. It is configured to extend the FileIO interface for better discoverability and ease-of-use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Main focus of the package is to provide access to all of the data stored in files. Therefore each format has its own type that is meant to provide easy way to see and extract data for further use. For implementation details, please see the dedicated pages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Right now, EEGIO supports following formats:","category":"page"},{"location":"","page":"Home","title":"Home","text":"BDF (load and save)\nEEG (load and save)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are interested in processing and analyzing EEG data in Julia, and would like a more general interface for working with data, check out Telepathy for which EEGIO serves as an IO backend. It should have reasonable default settings for start, while still allowing you to do all of the customisations included in EEGIO.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the 1.0 release, we would like to support loading and saving of all the formats included in EEG-BIDS specification. This includes support for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"EDF files\nEDF+ and BDF+ extensions\nEEGLab files (.set and .fdt)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to see other formats (or even better, help to implement them), please open an issue for it.\n\n\n","category":"page"},{"location":"#Other-packages","page":"Home","title":"Other packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, Julia ecosystem lacks a package serving as a singular entry point for EEG data (a role which EEGIO aspires to fill). There are however packages that implement reading and writing functions for some formats.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BDF/EDF: EDF.jl, EDFplus.jl, BDF.jl, BioSemiBDF\nBrainVision: brainvisionloader.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, there are more general packages that include IO functionality:\nNeuroimaging.jl and NeuroAnalyzer.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, there are many well established libraries in other languages that support reading and writing these files (along with tools for analysis). Most popular ones include EEGLab, FieldTrip, and Brainstorm for Matlab; MNE-Python for Python. You should be able to easily find more browsing Github or Google results.","category":"page"},{"location":"formats/bdf/#BDF","page":"BDF (BioSemi)","title":"BDF","text":"","category":"section"}]
}
