<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · EEGIO</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="EEGIO logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EEGIO</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Formats</span><ul><li><a class="tocitem" href="../formats/bdf/">BDF (BioSemi)</a></li><li><a class="tocitem" href="../formats/eeg/">EEG (BrainVision)</a></li></ul></li><li><a class="tocitem" href="../utils/">Utilities</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#BioSemi-BDF"><span>BioSemi BDF</span></a></li><li><a class="tocitem" href="#BrainVision-EEG"><span>BrainVision EEG</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="BioSemi-BDF"><a class="docs-heading-anchor" href="#BioSemi-BDF">BioSemi BDF</a><a id="BioSemi-BDF-1"></a><a class="docs-heading-anchor-permalink" href="#BioSemi-BDF" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EEGIO.BDF-Tuple{Array, Integer}" href="#EEGIO.BDF-Tuple{Array, Integer}"><code>EEGIO.BDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BDF(data::Array, sRate::Integer; path=&quot;&quot;, file=&quot;&quot;, kwargs...)</code></pre><p>Covenience constructor for BDF struct. To get a valid BDF struct, you need to provide the data and its sampling rate. All other keyword arguments are optional and will be passed to the BDFHeader constructor. Although optional, the more information you provide, the less likely you will face problems when importing the data into other software.</p><p><strong>Arguments</strong></p><ul><li><code>data::Array</code>: 2D matrix of data. Each row represents a sample and each column a channel.</li><li><code>sRate::Integer</code>: Sampling rate of the data in Hz.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>path::String</code>: Path to the folder where the file will be saved. If not provided, you will</li></ul><p>have to provide the full path when calling the <code>write_bdf</code> function.</p><ul><li><code>file::String</code>: Name of the file. If not provided, you will have to provide in the path.</li><li><code>subID::String</code>: Subject ID.</li><li><code>recID::String</code>: Recording ID.</li><li><code>startDate::String</code>: Date of the recording.</li><li><code>startTime::String</code>: Time of the recording.</li><li><code>recordDuration::Integer</code>: Duration of each data record in seconds.</li><li><code>chanLabels::Vector{String}</code>: Channel labels.</li><li><code>transducer::Vector{String}</code>: Transducer type, eg. &#39;active electrode&#39;.</li><li><code>physDim::Vector{String}</code>: Physical dimension of the data, eg. &#39;uV&#39;.</li><li><code>physMin::Vector{Int}</code>: Minimum physical value of the data.</li><li><code>physMax::Vector{Int}</code>: Maximum physical value of the data.</li><li><code>digMin::Vector{Int}</code>: Minimum digital value of the data.</li><li><code>digMax::Vector{Int}</code>: Maximum digital value of the data.</li><li><code>prefilt::Vector{String}</code>: Prefiltering of the data, eg. &#39;HP:0.1Hz LP:75Hz&#39;.</li><li><code>reserved::Vector{String}</code>: Reserved fields (usually empty).</li></ul><p><strong>Returns</strong></p><ul><li><code>BDF</code>: BDF struct.</li></ul><p>Additionally, this constructor provides validation checks that might help you avoid mistakes or getting the data distorted during conversion to Int24 while writing to disk.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a BDF struct with 10s of random data and 20 channels sampled at 256Hz.
BDF(rand(2560, 20), 256)</code></pre><p>If you already have a BDFHeader, you can use the default constructor:</p><pre><code class="language-julia hljs">BDF(header, data, path=&quot;path/to/file/&quot;, file=&quot;file.bdf&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/formats/BDF.jl#L163-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.BDFHeader-Tuple{Integer, Integer, Integer}" href="#EEGIO.BDFHeader-Tuple{Integer, Integer, Integer}"><code>EEGIO.BDFHeader</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BDFHeader(samples::Integer, channels::Integer, sRate::Integer; kwargs...)</code></pre><p>Convenience constructor for the BDFHeader struct. The only three necessary arguments is the number of samples in the data, the number of channels, and the sampling rate of signals. Other fields are optional, but providing them might improve compatibility with other software.</p><p><strong>Arguments</strong></p><ul><li><code>samples::Integer</code>: Number of samples in the data.</li><li><code>channels::Integer</code>: Number of channels in the data.</li><li><code>sRate::Integer</code>: Sampling rate of the data.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>subID::String</code>: Subject ID.</li><li><code>recID::String</code>: Recording ID.</li><li><code>startDate::String</code>: Date of the recording.</li><li><code>startTime::String</code>: Time of the recording.</li><li><code>recordDuration::Integer</code>: Duration of each data record in seconds.</li><li><code>chanLabels::Vector{String}</code>: Channel labels.</li><li><code>transducer::Vector{String}</code>: Transducer type, eg. &#39;active electrode&#39;.</li><li><code>physDim::Vector{String}</code>: Physical dimension of the data, eg. &#39;uV&#39;.</li><li><code>physMin::Vector{Int}</code>: Minimum physical value of the data.</li><li><code>physMax::Vector{Int}</code>: Maximum physical value of the data.</li><li><code>digMin::Vector{Int}</code>: Minimum digital value of the data.</li><li><code>digMax::Vector{Int}</code>: Maximum digital value of the data.</li><li><code>prefilt::Vector{String}</code>: Prefiltering of the data, eg. &#39;HP:0.1Hz LP:75Hz&#39;.</li><li><code>reserved::Vector{String}</code>: Reserved fields (usually empty).</li></ul><p><strong>Returns</strong></p><ul><li><code>BDFHeader</code>: A BDFHeader struct with the provided values.</li></ul><p>You might notice that couple of fields mentioned in the BDF specification are not included  in the constructor. These either have a fixed value or are calculated from provided values to reduce the risk of mistakes. If you want to change these values, you can overwrite the fields of the returned struct directly or use the default constructor and fill all the fields manually. However, this constructor provides additional validation checks that might help you avoid entering wrong values or getting the data distorted during conversion to Int24 while writing  to disk.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">header = BDFHeader(1024, 17, 256)</code></pre><pre><code class="language-julia hljs">header = BDFHeader(1024, 17, 256, subID=&quot;Subject 1&quot;, recID=&quot;Recording 1&quot;, startDate=&quot;01.01.2019&quot;, startTime=&quot;00:00:00&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/formats/BDF.jl#L32-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.read_bdf-Tuple{String}" href="#EEGIO.read_bdf-Tuple{String}"><code>EEGIO.read_bdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_bdf(f::String; kwargs...)</code></pre><p>Read data from a BDF file.</p><p>Providing a string containing valid path to a .bdf file will result in reading the data as a Float64 matrix with an added offset. Behavior of the function can be altered through additional keyword arguments listed below. Please consult the online documentation for a more thorough explanation of different options.</p><p><strong>Arguments:</strong></p><ul><li><code>f::String</code><ul><li>Path to the BDF file to be read.</li></ul></li></ul><p><strong>Keywords:</strong></p><ul><li><code>onlyHeader::Bool=false</code><ul><li>Indicates whether to read the header information with data points or just the header.</li></ul></li><li><code>addOffset::Bool=true</code><ul><li>Whether to add constant offset to data points to compensate for asymmetric digitalization done by the amplifier. This setting differs between software. Defaults to <code>true</code>.</li></ul></li><li><code>numPrecision::Type=Float64</code><ul><li>Specifies the numerical type of the data. Data points in BDF files are stored as signed 24-bit integers, therefore can be read as types with higher bit count per number. Possible tested options: <code>Float32</code>, <code>Float64</code>, <code>Int32</code>, <code>Int64</code>. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  <code>Float64</code>.</li></ul></li><li><code>chanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All</code><ul><li>Specifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.</li></ul></li><li><code>chanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None</code><ul><li>Specifies the subset of channel to omit while reading the data. Uses the same selectors as <code>chanSelect</code> and picked values are subtracted from the set of electrodes chosen by <code>chanSelect</code>. Default is set to :None.</li></ul></li><li><code>timeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All</code><ul><li>Specifies the part of the time course of the data to be read. BDF files are read one record at a time (just as they are written), so the user can indicate which records to read. Using integers will select records with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all records that fit this time span will be read. Using Symbol :All will read every record in the file. This is also the default.</li></ul></li><li><code>readStatus::Bool=true</code><ul><li>Specifies if the Status channel should be read. As this is a special channel, always placed at the end of the file and carrying trigger information along with some technical data about the hardware setup, this setting provides an option to ignore it. Please be aware, that its absence might generate errors in code that expects it (even if it is empty). Default is set to true. </li></ul></li></ul><p>Current implementation follows closely the specification formulated by <a href="https://www.biosemi.com/faq/file_format.htm">BioSemi</a> that extends EDF format from 16 to 24-bit. Therefore it will read only data produced by BioSemi equipment and software compliant with the specification. BDF+ extension is not yet implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/load/load_bdf.jl#L3-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.read_bdf_header-Tuple{IO}" href="#EEGIO.read_bdf_header-Tuple{IO}"><code>EEGIO.read_bdf_header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_bdf_header(::IO)</code></pre><p>Read the header of a BDF file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/load/load_bdf.jl#L91-L95">source</a></section></article><h2 id="BrainVision-EEG"><a class="docs-heading-anchor" href="#BrainVision-EEG">BrainVision EEG</a><a id="BrainVision-EEG-1"></a><a class="docs-heading-anchor-permalink" href="#BrainVision-EEG" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EEGIO.read_eeg-Tuple{String}" href="#EEGIO.read_eeg-Tuple{String}"><code>EEGIO.read_eeg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_eeg(f::String; kwargs...)</code></pre><p>Read data from an EEG file.</p><p>Providing a string containing valid path to a .eeg, .vhdr, or .vmrk file will result in  reading the data as a Float64 matrix (provided all files share their name). Behavior of  the function can be altered through additional keyword arguments listed below. Please  consult the online documentation for a more thorough explanation of different options.</p><p><strong>Arguments:</strong></p><ul><li><code>f::String</code><ul><li>Path to the EEG file (either .eeg, .vhdr, or .vmrk) to be read.</li></ul></li></ul><p><strong>Keywords:</strong></p><ul><li><code>onlyHeader::Bool=false</code><ul><li>Indicates whether to read the header information with data points or just the header.</li></ul></li><li><code>onlyMarkers::Bool=false</code><ul><li>Indicates whether to read the data points or just the header and markers.</li></ul></li><li><code>numPrecision::Type=Float64</code><ul><li>Specifies the numerical type of the data. Data points in EEG files are stored as 16-bit integers or 32-bit floats, therefore can be read as types with higher bit count per number. Possible tested options: <code>Float32</code>, <code>Float64</code>, <code>Int32</code>, <code>Int64</code>. Since there is no clear benefit (except amount of memory used) to using smaller number, the default is set to  <code>Float64</code>.</li></ul></li><li><code>chanSelect::Union{Int, Range, Vector{Int}, String, Vector{String}, Regex, Symbol}=:All</code><ul><li>Specifies the subset of channels to read from the data. Depending on the provided value you can select different subsets of channels. Using integers (either single number, range, or a vector) will select channels by their position in the data (e.g. chanSelect=[1,4,8], will pick the first, fourth, and eighth). Using strings or regex expression will pick all the channels with matching names stored in the header. Finally, you can provide symbols :None or :All to read neither or every channel available. Default is set to :All.</li></ul></li><li><code>chanIgnore::Union{Int, UnitRange, Vector{Int}, String, Vector{String}, Regex, Symbol}=:None</code><ul><li>Specifies the subset of channel to omit while reading the data. Uses the same selectors as <code>chanSelect</code> and picked values are subtracted from the set of electrodes chosen by <code>chanSelect</code>. Default is set to :None.</li></ul></li><li><code>timeSelect::Union{Int, UnitRange, Tuple{AbstractFloat}, Symbol}=:All</code><ul><li>Specifies the part of the time course of the data to be read. Using integers will select samples with those indexes in the data. Using a tuple of floats will be interpreted as start and stop values in seconds and all samples that fit this time span will be read. Using Symbol :All will read every sample in the file. This is also the default.</li></ul></li></ul><p>Current implementation follows closely the specification formulated by <a href="https://www.brainproducts.com/download/specification-of-brainvision-core-data-format-1-0/">BrainVision</a>. However the contents of the header and marker files can differ substantially,  even if recorded with BrainVision hardware. If your files are not read properly, open an issue on github and try to provide a sample dataset to reproduce the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/load/load_eeg.jl#L6-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.read_eeg_header-Tuple{String}" href="#EEGIO.read_eeg_header-Tuple{String}"><code>EEGIO.read_eeg_header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_eeg_header(::String)</code></pre><p>Reader the EEG header based on the name of file. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/load/load_eeg.jl#L112-L116">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EEGIO.pick_channels-Tuple{Any, Integer, Vector{String}}" href="#EEGIO.pick_channels-Tuple{Any, Integer, Vector{String}}"><code>EEGIO.pick_channels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EEGIO.pick_channels(channels, nChannels::Integer, chanLabels::Vector{String})</code></pre><p>Internal function used to properly select requested subset of channels from the data. It allows users to narrow down the number of read channels through numerical indexes, or name labels picked directly with a list or matched with regex expression.</p><p>Always returns a vector of indices corresponding to the picked channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Assume we have an object `raw` of type BDF with 10 channels.

# Picking the first channel of the data.
pick_channels(1, raw.header.nChannels, raw.header.chanLabels)</code></pre><pre><code class="language-julia hljs"># Picking the first 5 channels of the data.
pick_channels(1:5, raw.header.nChannels, raw.header.chanLabels)</code></pre><pre><code class="language-julia hljs"># Picking channels Fp1, Fp2, F7, F3, and Fz.
pick_channels([&quot;Fp1&quot;, &quot;Fp2&quot;, &quot;F7&quot;, &quot;F3&quot;, &quot;Fz&quot;], raw.header.nChannels, raw.header.chanLabels)</code></pre><pre><code class="language-julia hljs"># Picking all channels that contain the letter &quot;F&quot;.
pick_channels(r&quot;F&quot;, raw.header.nChannels, raw.header.chanLabels)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/pick_channels.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.pick_samples-Tuple{Any, Any}" href="#EEGIO.pick_samples-Tuple{Any, Any}"><code>EEGIO.pick_samples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EEGIO.pick_samples(records, header::BDFHeader)
EEGIO.pick_samples(samples, nDataSamples::Ineger, header::EEGHeader)</code></pre><p>Internal function used to properly pick the range of samples that should be read from every channel. Since data is stored differently in each format, specialized variants were written to read as much data as needed to satify the query without compromising efficiency. Please refer to the description of <code>timeSelect</code> keyword argument of particular read function for more detailed account of the picking behaviour.</p><p>Always returns a UnitRange.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Picking the first 10 records of the data (assuming `file` is an object of type BDF).
pick_samples(1:10, file.header)</code></pre><pre><code class="language-julia hljs"># Picking the first 10 seconds of the data (assuming `file` is an object of type EEG).
pick_samples((1.,10.), size(file.data,1), file.header)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/pick_samples.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Tuple{EEGData}" href="#Base.split-Tuple{EEGData}"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split(file::EEGData, timepoint)</code></pre><p>Allows for splitting the data into two objects at a specified timepoint. <code>timepoint</code> can be either a Float or an Integer. Depending on the format, the timepoint will be measured in different units. To preserve the structure of the underlying format, e.g. BDF files will be split based on the record duration. Returns two new EEGData objects with the split data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Splitting the data at the 10th second of the file.
data1, data2 = split(file, 10.)</code></pre><pre><code class="language-julia hljs"># Splitting the data at the 100th sample/record of the file.
data1, data2 = split(file, 100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/resize.jl#L202-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.crop!-Tuple{BDF, Any}" href="#EEGIO.crop!-Tuple{BDF, Any}"><code>EEGIO.crop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crop!(file::EEGData, timeSelect)</code></pre><p>Performs cropping in place. See <a href="#EEGIO.crop-Tuple{EEGData}"><code>crop</code></a> for more details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/resize.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.crop-Tuple{EEGData}" href="#EEGIO.crop-Tuple{EEGData}"><code>EEGIO.crop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crop(file::EEGData, timeSelect)</code></pre><p>Allows for cropping the data to a specified time window. <code>timeSelect</code> can be either an Integer,  a UnitRange, or a tuple of Floats. Depending on the format, the time window will be measured in different units. Since this keyword argument works exactly the same as in read functions, please refer to their documentation for more details on specific use cases. Returns a new EEGData object with the cropped data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Cropping the data to the first 10 seconds of the file.
data = crop(file, (1.,10.))</code></pre><pre><code class="language-julia hljs"># Cropping the data to the first 10 samples/records of the file.
data = crop(file, 1:10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/resize.jl#L77-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.select!-Tuple{BDF, Any}" href="#EEGIO.select!-Tuple{BDF, Any}"><code>EEGIO.select!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select!(file::EEGData, chanSelect)</code></pre><p>Performs channel selection in place. See <a href="#EEGIO.select-Tuple{EEGData}"><code>select</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/resize.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EEGIO.select-Tuple{EEGData}" href="#EEGIO.select-Tuple{EEGData}"><code>EEGIO.select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select(file::EEGData, chanSelect)</code></pre><p>Allows for selecting a subset of channels from the original data. <code>chanSelect</code> can be either an Integer, a UnitRange, a Vector of Integers/Strings, or a regular expression. Behaves exactly the same as in read functions. Returns a new EEGData object with only the selected channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Selecting the first 10 channels from the file.
data = select(file, 1:10)</code></pre><pre><code class="language-julia hljs"># Selecting channels 1, 3, 5, and 7 from the file.
data = select(file, [1,3,5,7])</code></pre><pre><code class="language-julia hljs"># Selecting only frontal channels (labels containing the letter &quot;F&quot;) from the file.
data = select(file, r&quot;F&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Telepathy-Software/EEGIO.jl/blob/d93deffbc5118be82c7d1ef29b1b9270eaf1338f/src/utils/resize.jl#L143-L164">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utils/">« Utilities</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 21 January 2023 16:38">Saturday 21 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
